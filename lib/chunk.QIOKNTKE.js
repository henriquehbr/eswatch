var P=Object.create,p=Object.defineProperty,h=Object.getPrototypeOf,E=Object.prototype.hasOwnProperty,b=Object.getOwnPropertyNames,C=Object.getOwnPropertyDescriptor,O=t=>p(t,"__esModule",{value:!0}),w=(t,e)=>()=>(e||(e={exports:{}},t(e.exports,e)),e.exports),L=(t,e,s)=>{if(O(t),e&&typeof e=="object"||typeof e=="function")for(let o of b(e))!E.call(t,o)&&o!=="default"&&p(t,o,{get:()=>e[o],enumerable:!(s=C(e,o))||s.enumerable});return t},u=t=>t&&t.__esModule?t:L(p(t!=null?P(h(t)):{},"default",{value:t,enumerable:!0}),t),m=w((Q,g)=>{"use strict";g.exports=t=>{const e=/^\\\\\?\\/.test(t),s=/[^\u0000-\u0080]+/.test(t);return e||s?t:t.replace(/\\/g,"/")}});import{existsSync as F}from"fs";const I=async t=>{try{return await new Promise((e,s)=>F(t)?e(t):s(`Couldn't find ${t} entry point`))}catch(e){throw new Error(e)}};var l=I;import{spawn as j}from"child_process";const k=t=>{const e=typeof t.run=="string"?t.run:`node ${t.outdir}`,[s]=e.split(" "),o=e.split(" ").slice(1),r=j(s,o,{stdio:"inherit"});return r};var v=k;const c=u(m());import S from"path";import D from"tiny-glob";const G=async t=>{const e=S.normalize(t),s=c.default(e),o=await D(s),r=o.map(c.default);return r};var d=G;import R from"minimist";const J=()=>{const t=R(process.argv.slice(2));return t};var a=J;import y from"path";import{fileURLToPath as _}from"url";import{builtinModules as N}from"module";const z=y.dirname(_(import.meta.url)),B=async()=>{const t=a(),e=t.format==="esm"?t.splitting:!1,s=!!t.watch,o=t.outext?{".js":t.outext}:{".js":".js"},r=t.outdir??y.join(z,"build"),n=[...N];if(!t.standalone){const{getDependencies:i}=await import("./helpers/index.js");n.push(...await i())}return t.external&&n.push(...t.external),{splitting:e,incremental:s,outExtension:o,outdir:r,external:n}};var f=B;import{readFileSync as M}from"fs";import T from"find-up";const lt=async()=>{const t=await T("package.json");if(t){const e=M(t,{encoding:"utf-8"}),s=JSON.parse(e),o=Object.keys(s.dependencies),r=Object.keys(s.devDependencies);return[...o,...r]}return[]};import U from"is-glob";const V=async t=>{const e=t._.length<1&&!t.entry;if(e)throw new Error("Missing entry point");const s=t.entry?[t.entry]:t._,o=s.map(async i=>U(i)?await d(i):await l(i)),r=await Promise.all(o),n=r.flat();return n};var x=V;const xt=async()=>{const t=a(),e=await x(t),{external:s,incremental:o,outExtension:r,outdir:n,splitting:i}=await f();return{bundle:t.bundle,entryPoints:e,format:t.format,incremental:o,minify:t.minify,outdir:n,outExtension:r,platform:t.platform,...t.bundle&&{external:s,splitting:i}}};export{lt as a,a as b,xt as c,l as d,v as e,d as f,f as g};
