var I=Object.create,a=Object.defineProperty,L=Object.getPrototypeOf,S=Object.prototype.hasOwnProperty,B=Object.getOwnPropertyNames,v=Object.getOwnPropertyDescriptor,O=t=>a(t,"__esModule",{value:!0}),R=(t,s)=>()=>(s||(s={exports:{}},t(s.exports,s)),s.exports),j=(t,s,e)=>{if(O(t),s&&typeof s=="object"||typeof s=="function")for(let r of B(s))!S.call(t,r)&&r!=="default"&&a(t,r,{get:()=>s[r],enumerable:!(e=v(s,r))||e.enumerable});return t},G=t=>t&&t.__esModule?t:j(a(t!=null?I(L(t)):{},"default",{value:t,enumerable:!0}),t),P=R((lt,y)=>{"use strict";y.exports=t=>{let s=/^\\\\\?\\/.test(t),e=/[^\u0000-\u0080]+/.test(t);return s||e?t:t.replace(/\\/g,"/")}});import C from"esbuild";import J from"rimraf";import D from"readline";import l from"path";import{spawn as T}from"child_process";var k=t=>{let s=l.parse(t).name;return s==="index"},W=(t,s)=>{let e=l.parse(t).name,r=s.outext||".js",i=e+r,n=l.resolve(s.outdir,i);return n},$=(t,s)=>{let e=t.find(k),r=e||t[0];return W(r,s)},z=(t,s)=>{if(typeof s.run=="string")return s.run;{let e=$(t,s);return"node "+e}},u=(t,s)=>{let e=z(t,s),[r]=e.split(" "),i=e.split(" ").slice(1),n=T(r,i,{stdio:"inherit"});return n},c,m=D.createInterface({input:process.stdin,output:process.stdout}),f=(t,s)=>new Promise(async e=>{s.clear&&console.clear(),c?.kill(),s.run?(m.pause(),c=u(t,s),c.on("close",()=>{m.resume(),s.watch?e():process.exit()})):(console.log(`${t.join(", ")} built successfully on ${s.outdir}`),m.close(),e())});import g from"path";import{fileURLToPath as N}from"url";import{builtinModules as V}from"module";var _=g.dirname(N(import.meta.url)),h=async t=>{let s=t.outext?{".js":t.outext}:{".js":".js"},e=[t.outdir||[_,"build"]].flat(),r=g.resolve(...e),i=[...V];if(!t.standalone){let{getDependencies:n}=await import("./helpers/getDependencies.js");i.push(...await n())}return t.external&&i.push(...t.external),{outExtension:s,outdir:r,external:i}};import q from"is-glob";var d=G(P());import A from"path";import M from"tiny-glob";var w=async t=>{let s=A.normalize(t),e=d.default(s),r=await M(e),i=r.map(d.default);return i};import{existsSync as U}from"fs";var x=async t=>{try{return await new Promise((s,e)=>U(t)?s(t):e(`Couldn't find ${t} entry point`))}catch(s){throw new Error(s)}},H=async t=>q(t)?await w(t):await x(t),b=async t=>{let s=t.map(H),e=await Promise.all(s),r=e.flat();return r},E=async(t,s)=>{let e=await b(t),{external:r,outExtension:i,outdir:n}=await h(s);return{outdir:n,outExtension:i,entryPoints:e,bundle:s.bundle,format:s.format,incremental:s.incremental,minify:s.minify,platform:s.platform,...s.bundle&&{external:r,splitting:s.splitting}}},p=async t=>{for(let s of t)await s()},K=async(t,s)=>{let e=await E(t,s);!s.keepfiles&&J.sync(e.outdir);let r=s.watch&&await C.startService(),i=(r||C).build.bind(void 0,e),n=f.bind(void 0,t,s),o=[i,n];if(s.watch){let F=await import("chokidar");F.watch(s.watch).on("ready",async()=>await p(o)).on("change",async()=>await p(o))}else await p(o)};export{K as initEsbuild};
