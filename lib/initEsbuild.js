var L=Object.create,n=Object.defineProperty,B=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty,O=Object.getOwnPropertyNames,R=Object.getOwnPropertyDescriptor,j=t=>n(t,"__esModule",{value:!0}),G=(t,e)=>()=>(e||(e={exports:{}},t(e.exports,e)),e.exports),T=(t,e,s)=>{if(j(t),e&&typeof e=="object"||typeof e=="function")for(let r of O(e))!v.call(t,r)&&r!=="default"&&n(t,r,{get:()=>e[r],enumerable:!(s=R(e,r))||s.enumerable});return t},W=t=>t&&t.__esModule?t:T(n(t!=null?L(B(t)):{},"default",{value:t,enumerable:!0}),t),P=G((ft,w)=>{"use strict";w.exports=t=>{let e=/^\\\\\?\\/.test(t),s=/[^\u0000-\u0080]+/.test(t);return e||s?t:t.replace(/\\/g,"/")}});import I from"esbuild";import H from"rimraf";import z from"readline";import{spawn as $}from"child_process";import k from"path";var p=t=>{let e=k.parse(t).name;return e==="index"};import d from"path";var u=(t,e)=>{let s=d.parse(t).name,r=e.outext||".js",i=s+r,o=d.resolve(e.outdir,i);return o},f=t=>{let e=t.entryPoints.find(p),s=e||t.entryPoints[0],r=u(s,t);return r},h=t=>{let e=typeof t.run=="string"?t.run:"node "+f(t),[s]=e.split(" "),r=e.split(" ").slice(1),i=$(s,r,{stdio:"inherit"});return i},a,l=z.createInterface({input:process.stdin,output:process.stdout}),g=t=>new Promise(async e=>{t.clear&&console.clear(),a?.kill(),t.run?(l.pause(),a=h(t),a.on("close",()=>{l.resume(),t.watch?e():process.exit()})):(console.log(`${t.entryPoints.join(", ")} built successfully on ${t.outdir}`),l.close(),e())});import y from"path";import{fileURLToPath as D}from"url";import{builtinModules as N}from"module";var V=y.dirname(D(import.meta.url)),x=async t=>{let e=t.outext?{".js":t.outext}:{".js":".js"},s=[t.outdir||[V,"build"]].flat(),r=y.resolve(...s),i=[...N];if(!t.standalone){let{getDependencies:o}=await import("./helpers/getDependencies.js");i.push(...await o())}return t.external&&i.push(...t.external),{outExtension:e,outdir:r,external:i}};import U from"is-glob";var c=W(P());import _ from"path";import A from"tiny-glob";var b=async t=>{let e=_.normalize(t),s=c.default(e),r=await A(s),i=r.map(c.default);return i};import{existsSync as M}from"fs";var E=async t=>{try{return await new Promise((e,s)=>M(t)?e(t):s(`Couldn't find ${t} entry point`))}catch(e){throw new Error(e)}},q=async t=>U(t)?await b(t):await E(t),C=async t=>{let e=t.map(q),s=await Promise.all(e),r=s.flat();return r},F=async t=>{let e=await C(t.entryPoints),{external:s,outExtension:r,outdir:i}=await x(t);return{outdir:i,outExtension:r,entryPoints:e,bundle:t.bundle,format:t.format,incremental:t.incremental,minify:t.minify,platform:t.platform,...t.bundle&&{external:s,splitting:t.splitting}}},m=async t=>{for(let e of t)await e()},J=async t=>{let e=await F(t);!t.keepfiles&&H.sync(e.outdir);let s=t.watch&&await I.startService(),r=(s||I).build.bind(void 0,e),i=g.bind(void 0,t),o=[r,i];if(t.watch){let S=await import("chokidar");S.watch(t.watch).on("ready",async()=>await m(o)).on("change",async()=>await m(o))}else await m(o)};export{J as initEsbuild};
